## 백준 10971번: 외판원 순회 2

---

### 설명

**TSP(Traveling Salesman Problem)**라고 불리는 굉장히 유명한 문제이다.

좌표 상의 여러개의 점들 사이의 최적 경로를 찾아야 하는 것으로, 굉장히 다양한 분야에서 응용될 수 있다고 한다.

알고리즘 계의 끝판왕 문제라고도 하는데.. 어떻게 풀어야할지 감이 잡히지 않아서 풀이법을 찾아봤다.

### 풀이

몇 가지 풀이법이 존재하는 것 같다.

> - 브루트포스 알고리즘, 백트래킹
> - 다이나믹 프로그래밍 (동적계획법)
> - 다익스트라 알고리즘

모든 풀이법에 대해 탐구해보자.

#### 브루트포스 알고리즘

brute: 짐승같은, 무식한
force: 힘

말 그대로, 무식하게 모든 경우의 수를 탐색하는 알고리즘이다. 탐색해야 할 자료구조가 선형이라면 **순차탐색**, 비선형 그래프라면 **깊이 우선 탐색(DFS, Depth First Search)**과 **너비 우선 탐색(BFS, Breadth First Search)**가 있다.

#### 백트래킹

브루트포스 알고리즘의 한 종류라고 볼 수 있다. 경로를 순회하되 **(한정조건)**에 걸리는 경우 순회를 멈추고 다시 뒤로 돌아가는 방법이다. 답이 아닌 경우를 제외하는 것이 마치 가지치기하는 것 같다고 하여 **가지치기** 방법이라고도 부른다. 어쨌든 가능한 경우의 수를 모두 탐색하기 때문에 브루트포스 알고리즘이라고 할 수도 있다. 백트래킹은 보통 DFS를 사용하여 구현하는 것이 일반적이다. 한정조건에 따라 이전 노드로 되돌아가는 형태가 DFS와 잘 맞아떨어지기 때문이다.

풀이의 수도코드는 아래와 같다.

```javascript
function solve(depth, index, cost) {
  if (depth가 끝까지 도달한 경우) {
    if (다시 출발한 지점으로 돌아갈 수 있는 경우) { // 출발 지점으로 돌아갈 수 없는 경우에는 비용이 적더라도 고려하면 안되기 때문
      min = Math.min(min, newCost); // 현재 저장하고 있는 최소 비용과 새롭게 구한 비용(순회에 들어간 비용 + 다시 출발 지점으로 돌아갈 때의 비용)의 크기를 비교
    }
    return ;
  }
  for (let i = 0; i < depth의 최대 크기; i++) {
    if (아직 탐색한 곳이 아닐 때 && 해당 지점으로 갈 수 있을 때(cost가 0이 아닌 경우)) {
      check[i] = true; // 더 깊은 depth로 들어가기 전 해당 경우 탐색했다는 표시
      solve(depth + 1, i, newCost); // 재귀 호출
      check[i] = false; // 이전 depth로 돌아온 경우 탐색을 위해 다시 false로 변경
    }
  }
}
```
